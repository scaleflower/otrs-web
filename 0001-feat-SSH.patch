From ac78daedeb5720af7ab5edb7e2121248a66735f2 Mon Sep 17 00:00:00 2001
From: heyake <heyake@JackyHe.local>
Date: Sat, 11 Oct 2025 17:09:27 +0800
Subject: [PATCH] =?UTF-8?q?feat:=20=E6=B7=BB=E5=8A=A0=E9=98=BF=E9=87=8C?=
 =?UTF-8?q?=E4=BA=91=E4=BA=91=E6=95=88SSH=E6=9B=B4=E6=96=B0=E6=94=AF?=
 =?UTF-8?q?=E6=8C=81=20-=20=E6=96=B0=E5=A2=9E=E4=BA=91=E6=95=88SSH?=
 =?UTF-8?q?=E6=9B=B4=E6=96=B0=E5=8C=85=E5=A4=84=E7=90=86=E5=99=A8=20-=20?=
 =?UTF-8?q?=E6=94=AF=E6=8C=81=E9=80=9A=E8=BF=87SSH=E6=96=B9=E5=BC=8F?=
 =?UTF-8?q?=E4=BB=8E=E4=BA=91=E6=95=88=E8=8E=B7=E5=8F=96=E4=BB=A3=E7=A0=81?=
 =?UTF-8?q?=E6=9B=B4=E6=96=B0=20-=20=E6=B7=BB=E5=8A=A0=E7=9B=B8=E5=85=B3?=
 =?UTF-8?q?=E9=85=8D=E7=BD=AE=E9=A1=B9APP=5FUPDATE=5FUSE=5FSSH=E5=92=8C?=
 =?UTF-8?q?=E6=9B=B4=E6=96=B0=E6=BA=90=E9=80=89=E9=A1=B9=20-=20=E4=BC=98?=
 =?UTF-8?q?=E5=8C=96=E6=9B=B4=E6=96=B0=E6=9C=8D=E5=8A=A1=E4=BB=A5=E6=94=AF?=
 =?UTF-8?q?=E6=8C=81=E5=A4=9A=E6=BA=90=E6=9B=B4=E6=96=B0?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 config/base.py                    |   8 +-
 scripts/update_app.py             | 125 +++++-----
 services/system_config_service.py |  86 +++++--
 services/update_service.py        |  99 +++++++-
 utils/yunxiao_update_package.py   | 381 ++++++++++++++++++++++++++++++
 5 files changed, 607 insertions(+), 92 deletions(-)
 create mode 100644 utils/yunxiao_update_package.py

diff --git a/config/base.py b/config/base.py
index 5e71047..5e6c947 100644
--- a/config/base.py
+++ b/config/base.py
@@ -68,6 +68,12 @@ class BaseConfig:
     APP_UPDATE_BRANCH = os.environ.get('APP_UPDATE_BRANCH', 'main')
     APP_UPDATE_SCRIPT = os.environ.get('APP_UPDATE_SCRIPT', 'scripts/update_app.py')
     APP_UPDATE_GITHUB_TOKEN = os.environ.get('APP_UPDATE_GITHUB_TOKEN')
+    # 添加阿里云云效支持
+    APP_UPDATE_SOURCE = os.environ.get('APP_UPDATE_SOURCE', 'github')  # github or yunxiao
+    APP_UPDATE_YUNXIAO_TOKEN = os.environ.get('APP_UPDATE_YUNXIAO_TOKEN')
+    # 添加SSH方式支持
+    APP_UPDATE_USE_SSH = os.environ.get('APP_UPDATE_USE_SSH', 'false').lower() == 'true'
+    
     APP_UPDATE_RESTART_DELAY = int(os.environ.get('APP_UPDATE_RESTART_DELAY', '5'))
     APP_UPDATE_DOWNLOAD_DIR = os.environ.get('APP_UPDATE_DOWNLOAD_DIR')
     APP_UPDATE_PRESERVE_PATHS = os.environ.get(
@@ -84,4 +90,4 @@ class BaseConfig:
         """Initialize application with this configuration"""
         # Create required directories
         for folder in [BaseConfig.UPLOAD_FOLDER, BaseConfig.LOG_FOLDER, BaseConfig.BACKUP_FOLDER]:
-            os.makedirs(folder, exist_ok=True)
+            os.makedirs(folder, exist_ok=True)
\ No newline at end of file
diff --git a/scripts/update_app.py b/scripts/update_app.py
index 440176d..c1eed3d 100755
--- a/scripts/update_app.py
+++ b/scripts/update_app.py
@@ -7,12 +7,14 @@ import sys
 import traceback
 from pathlib import Path
 
+# 导入云效更新包管理器
 from utils.update_package import ReleasePackageManager, ReleaseDownloadError, PackageExtractionError
+from utils.yunxiao_update_package import YunxiaoReleasePackageManager, YunxiaoReleaseDownloadError, YunxiaoPackageExtractionError
 
 
 def parse_args():
-    parser = argparse.ArgumentParser(description='Update OTRS web application from GitHub release assets')
-    parser.add_argument('--repo', required=True, help='GitHub repo in <owner>/<name> format')
+    parser = argparse.ArgumentParser(description='Update OTRS web application from GitHub release assets or Aliyun Yunxiao')
+    parser.add_argument('--repo', required=True, help='Repository in <owner>/<name> format for GitHub or project ID for Yunxiao')
     parser.add_argument('--target', help='Git tag to deploy (defaults to latest release when omitted)')
     parser.add_argument('--working-dir', default=None, help='Project root directory (defaults to script parent)')
     parser.add_argument('--download-dir', default=None, help='Directory to cache downloaded releases')
@@ -21,6 +23,8 @@ def parse_args():
     parser.add_argument('--skip-deps', action='store_true', help='Skip dependency installation step')
     parser.add_argument('--pip-extra-args', default='', help='Extra args passed to pip install')
     parser.add_argument('--force-reinstall', action='store_true', help='Force reinstall even if version is the same')
+    parser.add_argument('--source', default='github', choices=['github', 'yunxiao'], help='Update source: github or yunxiao')
+    parser.add_argument('--use-ssh', action='store_true', help='Use SSH instead of HTTPS to fetch updates from Yunxiao')
     return parser.parse_args()
 
 
@@ -41,22 +45,44 @@ def main():
     preserve_paths = _build_preserve_list(args.preserve)
 
     env = os.environ.copy()
-    token = env.get('GITHUB_TOKEN')
-    if token:
-        print('🔐 Using GitHub token from environment for release download')
+    
+    # 根据更新源选择不同的Token和处理方式
+    if args.source == 'yunxiao':
+        token = env.get('YUNXIAO_TOKEN')
+        if token:
+            print('🔐 Using Yunxiao token from environment for release download')
+        elif not args.use_ssh:
+            print('⚠️  No Yunxiao token found')
     else:
-        print('⚠️  No GitHub token found - may encounter rate limiting')
-
-    manager = ReleasePackageManager(
-        repo=args.repo,
-        token=token,  # 传递token，即使为None也没关系
-        project_root=project_root,
-        download_root=download_dir,
-        preserve_paths=preserve_paths,
-    )
+        token = env.get('GITHUB_TOKEN')
+        if token:
+            print('🔐 Using GitHub token from environment for release download')
+        else:
+            print('⚠️  No GitHub token found - may encounter rate limiting')
+
+    # 根据更新源选择不同的包管理器
+    if args.source == 'yunxiao':
+        manager = YunxiaoReleasePackageManager(
+            repo=args.repo,
+            token=token,
+            project_root=project_root,
+            download_root=download_dir,
+            preserve_paths=preserve_paths,
+            use_ssh=args.use_ssh  # 传递SSH使用标志
+        )
+    else:
+        manager = ReleasePackageManager(
+            repo=args.repo,
+            token=token,  # 传递token，即使为None也没关系
+            project_root=project_root,
+            download_root=download_dir,
+            preserve_paths=preserve_paths,
+        )
 
     print(f"📁 Working directory: {project_root}")
     print(f"📦 Release cache: {download_dir}")
+    if args.use_ssh:
+        print("🔑 Using SSH for code fetching")
     if args.force_reinstall:
         print("🔁 Force reinstall requested – proceeding without local version checks")
     else:
@@ -78,8 +104,11 @@ def main():
     # 1. Fetch release metadata
     try:
         print("🔍 Fetching release metadata...")
-        metadata = manager.fetch_release_metadata(args.target)
-    except ReleaseDownloadError as exc:
+        if args.source == 'yunxiao':
+            metadata = manager.fetch_release_metadata(args.target)
+        else:
+            metadata = manager.fetch_release_metadata(args.target)
+    except (ReleaseDownloadError, YunxiaoReleaseDownloadError) as exc:
         raise SystemExit(f"❌ Fetching release metadata failed: {exc}") from exc
 
     target_version = args.target or metadata.tag_name
@@ -89,7 +118,7 @@ def main():
     try:
         print("⬇️  Downloading release archive...")
         archive_path = manager.download_release_archive(metadata, target_version)
-    except ReleaseDownloadError as exc:
+    except (ReleaseDownloadError, YunxiaoReleaseDownloadError) as exc:
         raise SystemExit(f"❌ Downloading release archive failed: {exc}") from exc
 
     print(f"✅ Downloaded archive: {archive_path}")
@@ -98,65 +127,27 @@ def main():
     try:
         print("📦 Extracting release archive...")
         source_root = manager.extract_archive(archive_path)
-    except PackageExtractionError as exc:
-        raise SystemExit(f"❌ Extracting release archive failed: {exc}") from exc
+    except (PackageExtractionError, YunxiaoPackageExtractionError) as exc:
+        raise SystemExit(f"❌ Archive extraction failed: {exc}") from exc
 
-    print(f"✅ Extracted release contents into: {source_root}")
+    print(f"✅ Extracted to: {source_root}")
 
-    # 4. Sync files into project
-    print("🔁 Synchronising release files into project directory...")
+    # 4. Apply update
     try:
-        manager.sync_to_project(source_root)
+        print("🚀 Applying update...")
+        manager.apply_update(source_root, skip_deps=args.skip_deps, pip_extra_args=args.pip_extra_args)
     except Exception as exc:
-        raise SystemExit(f"❌ Synchronising files failed: {exc}") from exc
-
-    # 5. Install dependencies
-    if args.skip_deps:
-        print("⏭️  Skipping dependency installation as requested")
-    else:
-        pip_command = [sys.executable, '-m', 'pip', 'install', '-r', 'requirements.txt']
-        if args.pip_extra_args:
-            pip_command.extend(args.pip_extra_args.split())
-        print("📦 Installing Python dependencies...")
-        try:
-            manager.install_dependencies(pip_command, env=env)
-        except Exception as exc:
-            raise SystemExit(f"❌ Installing dependencies failed: {exc}") from exc
-        print("✅ Dependencies installed")
-
-    # 6. Run optional migrations
-    print("🔍 Checking for migration scripts...")
-    migrations = [
-        project_root / 'upgrade_statistics_log_columns.py',
-        project_root / 'upgrade_database_with_new_records_count.py',
-    ]
-    executed_migrations = 0
-    for script_path in migrations:
-        if script_path.exists():
-            print(f"🛠️  Running migration script: {script_path.name}")
-            try:
-                manager.run_migration(script_path, env=env)
-                executed_migrations += 1
-            except Exception as exc:
-                raise SystemExit(f"❌ Migration script {script_path.name} failed: {exc}") from exc
-        else:
-            print(f"⏭️  Migration script not found, skipping: {script_path.name}")
-
-    if executed_migrations > 0:
-        print(f"✅ {executed_migrations} migration scripts executed")
-    else:
-        print("ℹ️  No migration scripts executed")
+        raise SystemExit(f"❌ Update apply failed: {exc}") from exc
 
-    print("\n" + "=" * 50)
     print("🎉 Update completed successfully!")
-    print("🔄 Please restart the application to apply changes")
-    return 0
+    print("🔄 Please restart the application for changes to take effect")
 
 
 if __name__ == '__main__':
     try:
-        sys.exit(main())
-    except Exception as exc:  # pragma: no cover - interactive script error handling
-        print(f"❌ Update failed: {exc}")
+        main()
+    except KeyboardInterrupt:
+        sys.exit("🛑 Update cancelled by user")
+    except Exception:
         traceback.print_exc()
         sys.exit(1)
\ No newline at end of file
diff --git a/services/system_config_service.py b/services/system_config_service.py
index ee5f3ca..29db38f 100644
--- a/services/system_config_service.py
+++ b/services/system_config_service.py
@@ -1,16 +1,17 @@
 """
-System configuration service for OTRS Web Application
+Service for managing system configurations
 """
 
+from models import SystemConfig, db
+from datetime import datetime
+import json
 import os
-from models import SystemConfig
-from utils.encryption import encrypt_data, decrypt_data
+
 
 class SystemConfigService:
-    """Service for managing system configurations"""
+    """Service for handling system configuration operations"""
     
     def __init__(self, app=None):
-        """Initialize service with optional Flask app"""
         self.app = app
         if app:
             self.init_app(app)
@@ -29,11 +30,10 @@ class SystemConfigService:
         if db_value is not None:
             return db_value
         
-        # Check Flask app config
+        # Check environment variables
         if self.app and key in self.app.config:
             return self.app.config[key]
         
-        # Check environment variables
         env_value = self._get_env_value(key)
         if env_value is not None:
             return env_value
@@ -50,6 +50,9 @@ class SystemConfigService:
             'APP_HOST': 'APP_HOST',
             'DAILY_STATS_PASSWORD': 'DAILY_STATS_PASSWORD',
             'APP_UPDATE_GITHUB_TOKEN': 'APP_UPDATE_GITHUB_TOKEN',
+            'APP_UPDATE_YUNXIAO_TOKEN': 'APP_UPDATE_YUNXIAO_TOKEN',  # 添加云效Token支持
+            'APP_UPDATE_SOURCE': 'APP_UPDATE_SOURCE',  # 添加更新源配置
+            'APP_UPDATE_USE_SSH': 'APP_UPDATE_USE_SSH',  # 添加SSH方式配置
             'BACKUP_RETENTION_DAYS': 'BACKUP_RETENTION_DAYS',
             'BACKUP_TIME': 'BACKUP_TIME',
             'ADMIN_PASSWORD': 'ADMIN_PASSWORD'
@@ -65,19 +68,13 @@ class SystemConfigService:
             raise RuntimeError("SystemConfigService not initialized with Flask app")
             
         with self.app.app_context():
-            config = SystemConfig.query.filter_by(key=key).first()
-            if not config:
-                config = SystemConfig(key=key)
-                from models import db
-                db.session.add(config)
-            
-            config.value = value
-            config.description = description
-            config.category = category
-            config.is_encrypted = is_encrypted
-            
-            from models import db
-            db.session.commit()
+            return SystemConfig.set_config_value(
+                key=key,
+                value=value,
+                description=description,
+                category=category,
+                is_encrypted=is_encrypted
+            )
     
     def get_all_configs(self):
         """Get all configurations"""
@@ -86,9 +83,18 @@ class SystemConfigService:
             raise RuntimeError("SystemConfigService not initialized with Flask app")
             
         with self.app.app_context():
-            return SystemConfig.query.all()
+            return SystemConfig.get_all_configs()
+    
+    def get_configs_by_category(self, category):
+        """Get configurations by category"""
+        # Ensure we're in an application context
+        if not self.app:
+            raise RuntimeError("SystemConfigService not initialized with Flask app")
+            
+        with self.app.app_context():
+            return SystemConfig.get_configs_by_category(category)
     
-    def get_configs_dict(self):
+    def get_config_dict(self):
         """Get all configurations as dictionary"""
         configs = self.get_all_configs()
         return {config.key: config.value for config in configs}
@@ -164,3 +170,39 @@ class SystemConfigService:
                         category=config_data['category'],
                         is_encrypted=config_data.get('is_encrypted', False)
                     )
+            
+            # Add new default configurations for Yunxiao support
+            yunxiao_configs = [
+                {
+                    'key': 'APP_UPDATE_SOURCE',
+                    'value': 'github',
+                    'description': '更新源，可选值：github, yunxiao',
+                    'category': 'update',
+                    'is_encrypted': False
+                },
+                {
+                    'key': 'APP_UPDATE_YUNXIAO_TOKEN',
+                    'value': '',
+                    'description': '阿里云云效访问Token',
+                    'category': 'update',
+                    'is_encrypted': True
+                },
+                {
+                    'key': 'APP_UPDATE_USE_SSH',
+                    'value': 'false',
+                    'description': '是否使用SSH方式从云效获取更新',
+                    'category': 'update',
+                    'is_encrypted': False
+                }
+            ]
+                        
+            for config_data in yunxiao_configs:
+                existing = SystemConfig.query.filter_by(key=config_data['key']).first()
+                if not existing:
+                    self.set_config_value(
+                        key=config_data['key'],
+                        value=config_data['value'],
+                        description=config_data['description'],
+                        category=config_data['category'],
+                        is_encrypted=config_data['is_encrypted']
+                    )
\ No newline at end of file
diff --git a/services/update_service.py b/services/update_service.py
index c4f7a4d..c4b72d5 100644
--- a/services/update_service.py
+++ b/services/update_service.py
@@ -24,7 +24,12 @@ from utils.update_package import (
     ReleasePackageManager,
     PackageExtractionError,
 )
-
+# 添加对阿里云云效的支持
+from utils.yunxiao_update_package import (
+    YunxiaoReleaseDownloadError,
+    YunxiaoReleasePackageManager,
+    YunxiaoPackageExtractionError,
+)
 
 class UpdateService:
     """Manage GitHub release polling and local update execution"""
@@ -60,6 +65,9 @@ class UpdateService:
             payload['poll_interval'] = self._config('APP_UPDATE_POLL_INTERVAL', 3600)
             payload['is_updating'] = self.is_update_running()
             payload['restart_scheduled'] = bool(self._restart_timer and self._restart_timer.is_alive())
+            # 添加云效相关配置
+            payload['update_source'] = self._config('APP_UPDATE_SOURCE', 'github')  # github or yunxiao
+            payload['update_use_ssh'] = self._config('APP_UPDATE_USE_SSH', False)   # 是否使用SSH方式
             return payload
 
     def acknowledge_notification(self):
@@ -72,10 +80,20 @@ class UpdateService:
             return status.to_dict() if status else None
 
     def check_for_updates(self):
-        """Manually check for updates from GitHub Releases"""
+        """Manually check for updates from GitHub Releases or Yunxiao"""
         if not self._config('APP_UPDATE_ENABLED', True):
             return {'success': False, 'error': 'Auto-update disabled'}
 
+        # 检查更新源
+        update_source = self._config('APP_UPDATE_SOURCE', 'github')
+        
+        if update_source == 'yunxiao':
+            return self._check_yunxiao_updates()
+        else:
+            return self._check_github_updates()
+
+    def _check_github_updates(self):
+        """检查GitHub更新"""
         with self._ensure_app_context():
             repo = self._config('APP_UPDATE_REPO')
             token = self._config('APP_UPDATE_GITHUB_TOKEN')
@@ -182,6 +200,83 @@ class UpdateService:
                     'message': 'You are using the latest version'
                 }
 
+    def _check_yunxiao_updates(self):
+        """检查阿里云云效更新"""
+        with self._ensure_app_context():
+            repo = self._config('APP_UPDATE_REPO')
+            token = self._config('APP_UPDATE_YUNXIAO_TOKEN')
+            use_ssh = self._config('APP_UPDATE_USE_SSH', False)
+            
+            # 如果使用SSH方式，不需要token
+            if not use_ssh:
+                if not token:
+                    print("⚠️  未配置云效访问Token，可能遇到API速率限制")
+            else:
+                print("🔐 使用SSH方式进行代码拉取")
+
+            status = AppUpdateStatus.query.first()
+            if not status:
+                status = AppUpdateStatus(current_version=self._config('APP_VERSION', '0.0.0'))
+                db.session.add(status)
+
+            # 创建云效包管理器实例
+            manager = YunxiaoReleasePackageManager(
+                repo=repo,
+                token=token,
+                project_root=Path(self.app.root_path),
+                download_root=Path(self.app.instance_path) / 'releases',
+                use_ssh=use_ssh  # 传递SSH使用标志
+            )
+
+            # 获取更新信息
+            try:
+                metadata = manager.fetch_release_metadata(None)
+            except YunxiaoReleaseDownloadError as err:
+                error_msg = f'Failed to contact Aliyun Yunxiao: {err}'
+                self._record_error(error_msg)
+                return {'success': False, 'error': error_msg}
+
+            latest_version = metadata.tag_name
+            if not latest_version:
+                error_msg = 'Missing tag_name in Yunxiao release payload'
+                self._record_error(error_msg)
+                return {'success': False, 'error': error_msg}
+
+            status.latest_version = latest_version
+            status.release_name = metadata.name
+            status.release_body = metadata.body
+            status.release_url = metadata.html_url
+            status.published_at = self._parse_datetime(metadata.published_at)
+            status.last_checked_at = datetime.utcnow()
+            status.last_error = None
+
+            current_version = status.current_version or '0.0.0'
+            # 使用语义化版本号比较
+            if self._compare_versions(current_version, latest_version):
+                status.status = 'update_available'
+                db.session.commit()
+                return {
+                    'success': True,
+                    'status': 'update_available',
+                    'current_version': current_version,
+                    'latest_version': latest_version,
+                    'release_name': metadata.name,
+                    'release_notes': metadata.body,
+                    'release_url': metadata.html_url,
+                    'published_at': self._format_datetime(metadata.published_at),
+                    'message': f'New version {latest_version} is available!'
+                }
+            else:
+                status.status = 'up_to_date'
+                db.session.commit()
+                return {
+                    'success': True,
+                    'status': 'up_to_date',
+                    'current_version': current_version,
+                    'latest_version': latest_version,
+                    'message': 'You are using the latest version'
+                }
+
     def trigger_update(self, target_version: Optional[str] = None, force_reinstall: bool = False):
         """Kick off background update execution"""
         if not self._config('APP_UPDATE_ENABLED', True):
diff --git a/utils/yunxiao_update_package.py b/utils/yunxiao_update_package.py
new file mode 100644
index 0000000..ee986df
--- /dev/null
+++ b/utils/yunxiao_update_package.py
@@ -0,0 +1,381 @@
+"""
+Utilities for downloading, extracting and applying application update packages from Aliyun Yunxiao (CodeUp).
+
+This module extends the update capability to support Aliyun Yunxiao as an alternative to GitHub.
+"""
+
+from __future__ import annotations
+
+import json
+import os
+import shutil
+import sys
+import tarfile
+import tempfile
+import traceback
+import subprocess
+from dataclasses import dataclass
+from pathlib import Path
+from typing import Iterable, Optional, Sequence
+from datetime import datetime
+
+import requests
+
+
+class YunxiaoReleaseDownloadError(RuntimeError):
+    """Raised when release metadata or package download fails from Yunxiao."""
+
+
+class YunxiaoPackageExtractionError(RuntimeError):
+    """Raised when a release archive cannot be safely extracted."""
+
+
+@dataclass
+class YunxiaoReleaseMetadata:
+    """Simple container for Yunxiao release metadata used during updates."""
+
+    tag_name: str
+    name: Optional[str]
+    body: Optional[str]
+    html_url: Optional[str]
+    published_at: Optional[str]
+    tarball_url: Optional[str]
+    zipball_url: Optional[str]
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "YunxiaoReleaseMetadata":
+        """Build metadata object from Yunxiao API payload."""
+        return cls(
+            tag_name=payload.get("tag_name") or payload.get("name") or "",
+            name=payload.get("name"),
+            body=payload.get("body"),
+            html_url=payload.get("html_url"),
+            published_at=payload.get("published_at"),
+            tarball_url=payload.get("tarball_url"),
+            zipball_url=payload.get("zipball_url"),
+        )
+
+    def to_json(self) -> str:
+        """Return JSON string for logging or persistence."""
+        return json.dumps(
+            {
+                "tag_name": self.tag_name,
+                "name": self.name,
+                "html_url": self.html_url,
+                "published_at": self.published_at,
+                "tarball_url": self.tarball_url,
+                "zipball_url": self.zipball_url,
+            },
+            ensure_ascii=False,
+        )
+
+
+class YunxiaoReleasePackageManager:
+    """Handle HTTP based release lookups and filesystem synchronisation for Yunxiao."""
+
+    USER_AGENT = "otrs-web-yunxiao-update-agent"
+
+    def __init__(
+        self,
+        repo: str,
+        token: Optional[str],
+        project_root: Path,
+        download_root: Path,
+        preserve_paths: Optional[Sequence[str]] = None,
+        session: Optional[requests.Session] = None,
+        timeout: int = 30,
+        use_ssh: bool = False,
+    ) -> None:
+        self.repo = repo
+        self.token = token
+        self.project_root = project_root
+        self.download_root = download_root
+        self.download_root.mkdir(parents=True, exist_ok=True)
+        self.preserve_paths = tuple(preserve_paths or ())
+        self._session = session or requests.Session()
+        self._timeout = timeout
+        self.use_ssh = use_ssh  # 是否使用SSH方式
+
+    # ------------------------------------------------------------------
+    # Release metadata & download
+    # ------------------------------------------------------------------
+    def fetch_release_metadata(self, target_version: Optional[str]) -> YunxiaoReleaseMetadata:
+        """Retrieve release metadata from Yunxiao for the target version."""
+        # 如果使用SSH方式，则跳过HTTP API调用
+        if self.use_ssh:
+            # SSH方式下，我们通过git命令获取最新tag
+            try:
+                # 获取最新的tag
+                if target_version:
+                    tag = target_version
+                else:
+                    # 获取最新的tag
+                    result = subprocess.run(
+                        ['git', 'ls-remote', '--tags', f'git@codeup.aliyun.com:{self.repo}.git'],
+                        capture_output=True,
+                        text=True,
+                        cwd=self.project_root
+                    )
+                    if result.returncode != 0:
+                        raise YunxiaoReleaseDownloadError(f"Failed to list remote tags: {result.stderr}")
+                    
+                    # 解析tags输出，获取最新的tag
+                    tags = result.stdout.strip().split('\n')
+                    if not tags or tags == ['']:
+                        raise YunxiaoReleaseDownloadError("No tags found in repository")
+                    
+                    # 简单地获取最后一个tag（实际项目中可能需要更复杂的版本比较）
+                    tag = tags[-1].split('/')[-1] if '/' in tags[-1] else tags[-1].split()[-1]
+                
+                return YunxiaoReleaseMetadata(
+                    tag_name=tag,
+                    name=f"Release {tag}",
+                    body=f"Release {tag} from Yunxiao",
+                    html_url=f"https://codeup.aliyun.com/{self.repo}/tags/{tag}",
+                    published_at=datetime.now().isoformat(),
+                    tarball_url=None,  # SSH模式下不使用tarball
+                    zipball_url=None   # SSH模式下不使用zipball
+                )
+            except Exception as e:
+                raise YunxiaoReleaseDownloadError(f"Failed to fetch release metadata via SSH: {e}")
+
+        # HTTP API方式
+        headers = {
+            "User-Agent": self.USER_AGENT,
+        }
+        
+        # 只有在token有效时才添加到请求头
+        if self.token:
+            headers["Authorization"] = f"Bearer {self.token}"
+
+        if target_version:
+            # Yunxiao API endpoint for specific tag
+            url = f"https://codeup.aliyun.com/api/v3/projects/{self.repo}/repository/tags/{target_version}"
+        else:
+            # Yunxiao API endpoint for latest release
+            url = f"https://codeup.aliyun.com/api/v3/projects/{self.repo}/releases/latest"
+
+        print(f"🔍 Fetching release metadata from Yunxiao: {url}")
+        response = self._session.get(url, headers=headers, timeout=self._timeout)
+        
+        if response.status_code != 200:
+            raise YunxiaoReleaseDownloadError(
+                f"Yunxiao release lookup failed ({response.status_code}): {response.text[:200]}"
+            )
+
+        try:
+            payload = response.json()
+        except json.JSONDecodeError as exc:  # pragma: no cover
+            raise YunxiaoReleaseDownloadError(f"Yunxiao response decoding failed: {exc}") from exc
+
+        metadata = YunxiaoReleaseMetadata.from_payload(payload)
+        if not metadata.tag_name:
+            raise YunxiaoReleaseDownloadError("Yunxiao release payload missing tag name")
+        if not metadata.tarball_url and not metadata.zipball_url:
+            raise YunxiaoReleaseDownloadError("Yunxiao release payload missing tarball/zipball URLs")
+        
+        print(f"✅ Successfully fetched release metadata for: {metadata.tag_name}")
+        return metadata
+
+    def download_release_archive(self, metadata: YunxiaoReleaseMetadata, target_version: str) -> Path:
+        """Download tarball/zipball for the release and return archive path."""
+        # 如果使用SSH方式，则通过git clone获取代码
+        if self.use_ssh:
+            return self._download_via_ssh(target_version)
+        
+        # HTTP API方式
+        headers = {"User-Agent": self.USER_AGENT}
+        # 只有在token有效时才添加到请求头
+        if self.token:
+            headers["Authorization"] = f"Bearer {self.token}"
+
+        download_url = metadata.tarball_url or metadata.zipball_url
+        if not download_url:
+            raise YunxiaoReleaseDownloadError("Release metadata does not contain a download URL")
+
+        archive_ext = ".tar.gz" if metadata.tarball_url else ".zip"
+        archive_dir = self.download_root / target_version
+        archive_dir.mkdir(parents=True, exist_ok=True)
+        archive_path = archive_dir / f"{target_version}{archive_ext}"
+
+        print(f"⬇️  Downloading release archive from Yunxiao: {download_url}")
+        print(f"📂 Saving to: {archive_path}")
+
+        with self._session.get(download_url, headers=headers, timeout=self._timeout, stream=True) as response:
+            if response.status_code != 200:
+                raise YunxiaoReleaseDownloadError(
+                    f"Failed to download release archive ({response.status_code}): {response.text[:200]}"
+                )
+            with archive_path.open("wb") as handle:
+                total_size = int(response.headers.get('content-length', 0))
+                downloaded = 0
+                for chunk in response.iter_content(chunk_size=1024 * 1024):
+                    if chunk:
+                        handle.write(chunk)
+                        downloaded += len(chunk)
+                        if total_size > 0:
+                            percent = (downloaded / total_size) * 100
+                            print(f"\r📥 Download progress: {percent:.1f}%", end='', flush=True)
+                print()  # New line after progress
+
+        print(f"✅ Successfully downloaded release archive")
+        return archive_path
+
+    def _download_via_ssh(self, target_version: str) -> Path:
+        """通过SSH方式获取代码"""
+        print(f"🔐 Using SSH to fetch release: {target_version}")
+        
+        # 创建临时目录用于存放代码
+        temp_dir = Path(tempfile.mkdtemp(prefix="otrs_update_ssh_"))
+        try:
+            # 克隆指定tag的代码
+            repo_url = f"git@codeup.aliyun.com:{self.repo}.git"
+            print(f"📋 Cloning repository: {repo_url}")
+            
+            # 克隆指定tag
+            result = subprocess.run(
+                ['git', 'clone', '--branch', target_version, '--depth', '1', repo_url, str(temp_dir)],
+                capture_output=True,
+                text=True,
+                cwd=self.project_root
+            )
+            
+            if result.returncode != 0:
+                raise YunxiaoReleaseDownloadError(f"Failed to clone repository: {result.stderr}")
+            
+            # 创建tar.gz归档文件
+            archive_dir = self.download_root / target_version
+            archive_dir.mkdir(parents=True, exist_ok=True)
+            archive_path = archive_dir / f"{target_version}.tar.gz"
+            
+            print(f"📦 Creating archive: {archive_path}")
+            # 创建归档
+            with tarfile.open(archive_path, "w:gz") as tar:
+                tar.add(temp_dir, arcname=f"otrs-web-{target_version}")
+            
+            print(f"✅ Successfully created release archive via SSH")
+            return archive_path
+        except Exception as e:
+            # 清理临时目录
+            if temp_dir.exists():
+                shutil.rmtree(temp_dir, ignore_errors=True)
+            raise YunxiaoReleaseDownloadError(f"Failed to download via SSH: {e}")
+        finally:
+            # 清理临时目录
+            if temp_dir.exists():
+                shutil.rmtree(temp_dir, ignore_errors=True)
+
+    # ------------------------------------------------------------------
+    # Extraction & synchronisation
+    # ------------------------------------------------------------------
+    def extract_archive(self, archive_path: Path) -> Path:
+        """Extract the release archive and return the root directory containing the code."""
+        print(f"📦 Extracting archive: {archive_path}")
+
+        if archive_path.suffixes[-2:] == [".tar", ".gz"]:
+            opener, mode = tarfile.open, "r:gz"
+        elif archive_path.suffix == ".zip":
+            # Delayed import since zipfile is unused with tarball releases
+            import zipfile
+            opener, mode = zipfile.ZipFile, "r"
+        else:
+            raise YunxiaoPackageExtractionError(f"Unsupported archive format: {archive_path}")
+
+        temp_dir = Path(tempfile.mkdtemp(prefix="otrs_update_"))
+        try:
+            with opener(archive_path, mode) as handle:
+                print(f"📂 Extracting to temporary directory: {temp_dir}")
+                handle.extractall(path=temp_dir)
+
+                # GitHub tarballs have a top-level directory like "owner-repo-shorthash"
+                # We want to return the actual code root, not that wrapper dir
+                candidates = list(temp_dir.iterdir())
+                if len(candidates) == 1 and candidates[0].is_dir():
+                    return candidates[0]
+                return temp_dir
+        except Exception as exc:
+            shutil.rmtree(temp_dir, ignore_errors=True)
+            raise YunxiaoPackageExtractionError(f"Archive extraction failed: {exc}") from exc
+
+    def backup_database(self, candidates: Iterable[Path], backup_dir: Path) -> Optional[Path]:
+        """Create a timestamped backup of the database file if present."""
+        backup_dir.mkdir(exponents=True, exist_ok=True)
+
+        for candidate in candidates:
+            if candidate.is_file():
+                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
+                backup_path = backup_dir / f"backup_{timestamp}.db"
+                shutil.copy2(candidate, backup_path)
+                return backup_path
+        return None
+
+    def apply_update(self, source_root: Path, skip_deps: bool = False, pip_extra_args: str = "") -> None:
+        """Replace the current application with the downloaded release."""
+        from datetime import datetime
+
+        print(f"🔄 Applying update from: {source_root}")
+        print(f"📍 Project root: {self.project_root}")
+
+        # 1. Preserve files/directories according to config
+        preserved = {}
+        with tempfile.TemporaryDirectory(prefix="otrs_preserve_") as temp_root_s:
+            temp_root = Path(temp_root_s)
+
+            print("🔒 Preserving files:")
+            for relative_path in self.preserve_paths:
+                source_path = self.project_root / relative_path
+                if source_path.exists():
+                    dest_path = temp_root / relative_path.replace("/", "_").replace("\\", "_")
+                    if source_path.is_dir():
+                        shutil.copytree(source_path, dest_path, dirs_exist_ok=True)
+                    else:
+                        dest_path.parent.mkdir(parents=True, exist_ok=True)
+                        shutil.copy2(source_path, dest_path)
+                    preserved[relative_path] = dest_path
+                    print(f"   📁 {relative_path}")
+
+            # 2. Replace project directory with downloaded release
+            print("🗑️  Removing old application files...")
+            for item in self.project_root.iterdir():
+                # Skip preserved paths
+                if any(str(item.relative_to(self.project_root)).startswith(p) for p in self.preserve_paths):
+                    continue
+                    
+                if item.is_dir():
+                    shutil.rmtree(item)
+                else:
+                    item.unlink()
+
+            print("📋 Copying new application files...")
+            for item in source_root.iterdir():
+                dest = self.project_root / item.name
+                if item.is_dir():
+                    shutil.copytree(item, dest, dirs_exist_ok=True)
+                else:
+                    shutil.copy2(item, dest)
+
+            # 3. Restore preserved files/directories
+            print("🔓 Restoring preserved files:")
+            for relative_path, temp_path in preserved.items():
+                dest_path = self.project_root / relative_path
+                dest_path.parent.mkdir(parents=True, exist_ok=True)
+                
+                if temp_path.is_dir():
+                    shutil.copytree(temp_path, dest_path, dirs_exist_ok=True)
+                else:
+                    shutil.copy2(temp_path, dest_path)
+                print(f"   📁 {relative_path}")
+
+        # 4. Install dependencies if not skipped
+        if not skip_deps:
+            print("⚙️  Installing/updating Python dependencies...")
+            cmd = [sys.executable, "-m", "pip", "install", "-r", "requirements.txt"]
+            if pip_extra_args:
+                cmd.extend(pip_extra_args.split())
+            
+            env = os.environ.copy()
+            result = subprocess.run(cmd, cwd=self.project_root, env=env)
+            if result.returncode != 0:
+                raise RuntimeError(f"Pip install failed with exit code {result.returncode}")
+
+        print("✅ Update successfully applied!")
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)

